# Ralph loop (https://github.com/snarktank/ralph) — each agent runs in a fresh
# session with clean context. Memory persists via git history and progress files.
id: feature-dev
name: Feature Development Workflow
version: 5
description: |
  Story-based execution pipeline. Planner decomposes tasks into user stories.
  Setup prepares the environment and establishes baseline.
  Developer implements each story (with tests) in a fresh session. Verifier checks each story.
  Then integration/E2E testing, PR creation, and code review.

polling:
  model: sonnet
  timeoutSeconds: 120

agents:
  - id: planner
    name: Planner
    role: analysis
    description: Decomposes tasks into ordered user stories.
    workspace:
      baseDir: agents/planner
      files:
        AGENTS.md: agents/planner/AGENTS.md
        SOUL.md: agents/planner/SOUL.md
        IDENTITY.md: agents/planner/IDENTITY.md

  - id: setup
    name: Setup
    role: coding
    description: Prepares environment, creates branch, establishes baseline.
    workspace:
      baseDir: agents/setup
      files:
        AGENTS.md: ../../agents/shared/setup/AGENTS.md
        SOUL.md: ../../agents/shared/setup/SOUL.md
        IDENTITY.md: ../../agents/shared/setup/IDENTITY.md

  - id: developer
    name: Developer
    role: coding
    description: Implements features, writes tests, creates PRs.
    workspace:
      baseDir: agents/developer
      files:
        AGENTS.md: agents/developer/AGENTS.md
        SOUL.md: agents/developer/SOUL.md
        IDENTITY.md: agents/developer/IDENTITY.md

  - id: verifier
    name: Verifier
    role: verification
    description: Quick sanity check - did developer actually do the work?
    workspace:
      baseDir: agents/verifier
      skills:
        - agent-browser
      files:
        AGENTS.md: ../../agents/shared/verifier/AGENTS.md
        SOUL.md: ../../agents/shared/verifier/SOUL.md
        IDENTITY.md: ../../agents/shared/verifier/IDENTITY.md

  - id: tester
    name: Tester
    role: testing
    description: Integration and E2E testing after all stories are implemented.
    workspace:
      baseDir: agents/tester
      files:
        AGENTS.md: agents/tester/AGENTS.md
        SOUL.md: agents/tester/SOUL.md
        IDENTITY.md: agents/tester/IDENTITY.md

  - id: reviewer
    name: Reviewer
    role: analysis
    description: Reviews PRs, requests changes or approves.
    workspace:
      baseDir: agents/reviewer
      skills:
        - agent-browser
      files:
        AGENTS.md: agents/reviewer/AGENTS.md
        SOUL.md: agents/reviewer/SOUL.md
        IDENTITY.md: agents/reviewer/IDENTITY.md

steps:
  - id: plan
    agent: planner
    input: |
      Decompose the following task into ordered user stories for autonomous execution.

      TASK:
      {{task}}

      Instructions:
      1. Explore the codebase to understand the stack, conventions, and patterns
      2. Break the task into small user stories (max 20)
      3. Order by dependency: schema/DB first, backend, frontend, integration
      4. Each story must fit in one developer session (one context window)
      5. Every acceptance criterion must be mechanically verifiable
      6. Always include "Typecheck passes" as the last criterion in every story
      7. Every story MUST include test criteria — "Tests for [feature] pass"
      8. The developer is expected to write tests as part of each story
      9. BASE_BRANCH is where the PR will merge INTO (the PR target).
         If the task specifies "PR Base:" or "PR target:", use that value.
         Otherwise default to the repo's default branch (master or main).
      10. BRANCH is the working branch where code will be written.
          It must ALWAYS be a NEW branch created from BASE_BRANCH.
          Never work directly on BASE_BRANCH — always create a child branch.
          Name it descriptively, e.g. feat/sprint1-dto-foundation.

      Reply with:
      STATUS: done
      REPO: /path/to/repo
      BASE_BRANCH: branch-to-merge-into (PR target)
      BRANCH: new-working-branch-name (created from BASE_BRANCH)
      STORIES_JSON: [ ... array of story objects ... ]
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: setup
    agent: setup
    input: |
      Prepare the development environment for this feature.

      TASK:
      {{task}}

      REPO: {{repo}}
      BASE_BRANCH: {{base_branch}}
      BRANCH: {{branch}}

      Instructions:
      1. cd into the repo
      2. Checkout the base branch and pull latest:
         git checkout {{base_branch}} && git pull origin {{base_branch}}
      3. Create the working branch FROM the base branch:
         git checkout -b {{branch}}
      4. Read build config (package.json, pom.xml, build.gradle, Makefile — whatever exists),
         CI config, and test config to understand the build/test setup
      5. Ensure .gitignore exists — if missing, create one appropriate for the detected stack
      6. Set up runtime environment if needed:
         - Java projects: export JAVA_HOME=/home/agent/.local/java/jdk8u412-b08 && export PATH=$JAVA_HOME/bin:$PATH
         - Node projects: source ~/.bashrc or use nvm
      7. Ensure .gitignore includes agent artifact patterns (add if missing):
         - progress-*.txt
         - mvnw, mvnw.cmd  (build wrappers should not be committed by agents)
      8. Run the build to establish a baseline
      9. Run the tests to establish a baseline
      10. Report what you found

      Reply with:
      STATUS: done
      BUILD_CMD: <build command>
      TEST_CMD: <test command>
      CI_NOTES: <brief CI notes>
      BASELINE: <baseline status>
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: implement
    agent: developer
    type: loop
    loop:
      over: stories
      completion: all_done
      fresh_session: true
      verify_each: true
      verify_step: verify
    input: |
      Implement the following user story. You are working on ONE story in a fresh session.

      TASK (overall):
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      BUILD_CMD: {{build_cmd}}
      TEST_CMD: {{test_cmd}}

      CURRENT STORY:
      {{current_story}}

      COMPLETED STORIES:
      {{completed_stories}}

      STORIES REMAINING: {{stories_remaining}}

      VERIFY FEEDBACK (if retrying):
      {{verify_feedback}}

      PROGRESS LOG:
      {{progress}}

      Instructions:
      1. Read progress-{{run_id}}.txt — especially the Codebase Patterns section
      2. Pull latest on the branch
      3. Implement this story only
      4. Write tests for this story's functionality
      5. Run typecheck / build
      6. Run tests to confirm they pass
      7. Commit: feat: {{current_story_id}} - {{current_story_title}}
         ⚠️ NEVER commit: mvnw, mvnw.cmd, gradlew, progress-*.txt, .env, *.iml, .idea/
         These are local artifacts — never stage or commit them.
      8. Append to progress-{{run_id}}.txt
      9. Update Codebase Patterns if you found reusable patterns

      Reply with:
      STATUS: done
      CHANGES: what you implemented
      TESTS: what tests you wrote
    expects: "STATUS: done"
    max_retries: 2
    on_fail:
      escalate_to: human

  - id: verify
    agent: verifier
    input: |
      Verify the developer's work on this story.

      TASK (overall):
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      CHANGES: {{changes}}
      TEST_CMD: {{test_cmd}}

      CURRENT STORY:
      {{current_story}}

      PROGRESS LOG:
      {{progress}}

      ⚠️ HARD RULES — non-negotiable:
      - You MUST actually run {{test_cmd}} and {{build_cmd}}. Static code review is NOT verification.
      - If the runtime/build tool is missing, reply STATUS: retry immediately.
        Do NOT substitute with code reading or "looks correct" analysis.
      - If tests FAIL (non-zero exit), reply STATUS: retry with the exact failure output.

      Environment setup (run before any build/test commands):
      ```
      export JAVA_HOME=/home/agent/.local/java/jdk8u412-b08
      export PATH=$JAVA_HOME/bin:$PATH
      cd {{repo}}
      ```

      Check:
      1. Code exists (not just TODOs or placeholders)
      2. Each acceptance criterion for the story is met
      3. Tests were written for this story's functionality
      4. Run {{build_cmd}} — must exit 0
      5. Run {{test_cmd}} — must exit 0
      6. No obvious incomplete work

      ## Visual Verification (Frontend Changes)
      Has frontend changes: {{has_frontend_changes}}

      If {{has_frontend_changes}} is 'true', you MUST also perform visual verification:
      1. Use the agent-browser skill to visually inspect the changed UI
      2. Open the changed HTML file directly (file:// URL) or spin up a local dev server if the project requires one
      3. Take a screenshot of the rendered page
      4. Visually confirm:
         - Layout renders correctly (no broken/overlapping elements)
         - Styling is applied as expected (colors, fonts, spacing)
         - All visible elements from the story are present and properly positioned
         - No missing images, icons, or visual assets
         - Text is readable and not clipped or hidden
      5. A visual PASS means: the page renders without broken layout, missing elements, or overlapping content
      6. A visual FAIL means: broken layout, missing/invisible elements, overlapping or misaligned content, unstyled raw HTML, or obvious rendering errors
      7. Include your visual findings in VERIFIED output

      If {{has_frontend_changes}} is 'false', skip visual verification entirely.

      Reply with:
      STATUS: done
      VERIFIED: What you confirmed

      Or if incomplete:
      STATUS: retry
      ISSUES:
      - What's missing or incomplete
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 2
      on_exhausted:
        escalate_to: human

  - id: test
    agent: tester
    input: |
      Integration and E2E testing of the implementation.

      TASK:
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      CHANGES: {{changes}}
      BUILD_CMD: {{build_cmd}}
      TEST_CMD: {{test_cmd}}

      PROGRESS LOG:
      {{progress}}

      ⚠️ HARD RULES — non-negotiable:
      - You MUST actually run {{test_cmd}}. Static code review is NOT testing.
      - If the runtime is missing, reply STATUS: retry immediately with explanation.
        Do NOT substitute with "looks correct" analysis or compile-only checks.
      - If tests FAIL, reply STATUS: retry with the exact failure output.

      Environment setup (run before any build/test commands):
      ```
      export JAVA_HOME=/home/agent/.local/java/jdk8u412-b08
      export PATH=$JAVA_HOME/bin:$PATH
      cd {{repo}}
      ```

      Your job (integration/E2E testing — unit tests were already written per-story):
      1. Run the full test suite ({{test_cmd}}) to confirm everything passes together
      2. Look for integration issues between stories
      3. If this is a UI feature, use agent-browser to test it end-to-end
      4. Check cross-cutting concerns: error handling, edge cases across features
      5. Verify the overall feature works as a cohesive whole

      Reply with:
      STATUS: done
      RESULTS: What you tested and the outcomes

      Or if issues found:
      STATUS: retry
      FAILURES:
      - Specific test failures or bugs found
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 2
      on_exhausted:
        escalate_to: human

  - id: pr
    agent: developer
    input: |
      Create a pull request for your changes.

      TASK:
      {{task}}

      REPO: {{repo}}
      BRANCH: {{branch}}
      BASE_BRANCH: {{base_branch}}
      CHANGES: {{changes}}
      RESULTS: {{results}}

      PROGRESS LOG:
      {{progress}}

      Create a PR with:
      - Clear title summarizing the change
      - Description explaining what and why
      - Reference to what was tested

      Use: gh pr create --base {{base_branch}}
      (IMPORTANT: always pass --base explicitly — never rely on the repo default branch)

      Reply with:
      STATUS: done
      PR: URL to the pull request
    expects: "STATUS: done"
    on_fail:
      escalate_to: human

  - id: review
    agent: reviewer
    input: |
      Review the pull request.

      PR: {{pr}}
      TASK: {{task}}
      CHANGES: {{changes}}

      PROGRESS LOG:
      {{progress}}

      Review for:
      - Code quality and clarity
      - Potential bugs or issues
      - Test coverage
      - Follows project conventions

      Use: gh pr view, gh pr diff to read the PR.

      IMPORTANT: Post your review to the PR on GitHub using:
      - If approving: gh pr review <number> --approve --body "your review summary"
      - If requesting changes: gh pr review <number> --request-changes --body "your feedback"

      ## Visual Review (Frontend Changes)
      Has frontend changes: {{has_frontend_changes}}

      If {{has_frontend_changes}} is 'true', you MUST also perform a visual design review:
      1. Check out the branch: git checkout {{branch}}
      2. Use the agent-browser skill to open the changed page (file:// URL or local dev server)
      3. Take a screenshot of the rendered page
      4. Evaluate visual polish and design quality:
         - Does the UI look polished and intentional, not rough or placeholder-quality?
         - Are colors, typography, and spacing consistent with the rest of the project?
         - Is the layout visually balanced and well-aligned?
         - Do interactive elements look clickable/tappable?
         - Is the overall design cohesive — does it feel like part of the same product?
      5. This is a DESIGN review, not a structural check — the verify step already confirmed elements render. You are checking whether the result looks GOOD.
      6. Include your visual design assessment in the review output

      If {{has_frontend_changes}} is 'false', skip visual review entirely.

      If changes needed, add comments to the PR explaining what needs to change.

      ⚠️ CRITICAL — reporting rules:
      - If APPROVED: write output to file then call `step complete`
      - If CHANGES REQUESTED: write output to file then call `step fail`
        (step fail triggers automatic re-implementation — do NOT call step complete)

      Reply with:
      STATUS: done
      DECISION: approved

      Or if changes needed:
      STATUS: retry
      DECISION: changes_requested
      FEEDBACK:
      - What needs to change
    expects: "STATUS: done"
    on_fail:
      retry_step: implement
      max_retries: 3
      on_exhausted:
        escalate_to: human
